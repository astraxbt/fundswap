"use client";import React, { useState, useEffect, useCallback } from "react";import { useWallet } from '@solana/wallet-adapter-react';import { PublicKey, ComputeBudgetProgram, TransactionMessage, VersionedTransaction } from '@solana/web3.js';import { Wallet, RefreshCw, Plus, Copy, ChevronDown, ChevronUp, Loader2 } from "lucide-react";import { Button } from "@/components/ui/button";import { Card, CardContent } from "@/components/ui/card";import { toast } from 'sonner';import { getAllTradingAddresses, checkPrivateBalance, checkPublicBalance, TRADING_BASE_CHALLENGE } from './utils';import { LightSystemProgram, defaultTestStateTreeAccounts, createRpc, selectMinCompressedSolAccountsForTransfer } from '@lightprotocol/stateless.js';export default function WalletManagement() {  const { publicKey, sendTransaction, wallet, signMessage, connected } = useWallet();    const [tradingAddresses, setTradingAddresses] = useState<Array<{ address: string, timestamp: number, index: number }>>([]);  const [generatingAddress, setGeneratingAddress] = useState(false);  const [queryingAddresses, setQueryingAddresses] = useState(false);  const [expandedAddresses, setExpandedAddresses] = useState<Record<string, boolean>>({});  const [addressBalances, setAddressBalances] = useState<Record<string, { public: string, private: string, total: string }>>({});  const [balanceUpdateCounter, setBalanceUpdateCounter] = useState(0);    const [showTopUpInput, setShowTopUpInput] = useState<Record<string, boolean>>({});  const [topUpAmounts, setTopUpAmounts] = useState<Record<string, string>>({});  const [toppingUp, setToppingUp] = useState(false);  const [topUpAddress, setTopUpAddress] = useState('');  const [status, setStatus] = useState('');  const [error, setError] = useState('');  const displayTradingAddresses = async () => {    if (!publicKey || !signMessage) {      toast.error('Please connect your wallet');      return;    }        setGeneratingAddress(true);    setError('');        try {      const message = new TextEncoder().encode(TRADING_BASE_CHALLENGE);      await signMessage(message);            const addresses = await getAllTradingAddresses(publicKey, signMessage, 3);            const formattedAddresses = addresses.map((addr, index) => ({        address: addr.publicKey.toString(),        timestamp: Date.now(),        index: addr.index      }));            setTradingAddresses(formattedAddresses);      setExpandedAddresses(prev => {        const newState = { ...prev };        formattedAddresses.forEach(addr => {          if (newState[addr.address] === undefined) {            newState[addr.address] = true;          }        });        return newState;      });            await queryTradingAddresses();            toast.success('Trading addresses generated successfully');    } catch (err: any) {      console.error('Error generating trading addresses:', err);      setError(err.message || 'Failed to generate trading addresses');      toast.error('Failed to generate trading addresses');    } finally {      setGeneratingAddress(false);    }  };  const queryTradingAddresses = async () => {    if (tradingAddresses.length === 0) return;        setQueryingAddresses(true);        try {      const addressesWithBalances: Record<string, { public: string, private: string, total: string }> = {};            for (const address of tradingAddresses) {        try {          const publicBalance = await checkPublicBalance(address.address);          const privateBalance = await checkPrivateBalance(address.address);                    const totalBalance = (parseFloat(publicBalance) + parseFloat(privateBalance)).toFixed(4);                    addressesWithBalances[address.address] = {            public: publicBalance,            private: privateBalance,            total: totalBalance          };        } catch (err) {          console.error(`Error checking balances for ${address}:`, err);          addressesWithBalances[address.address] = {            public: "0.0000",            private: "0.0000",            total: "0.0000"          };        }      }            console.log("Setting address balances:", addressesWithBalances);      setAddressBalances(addressesWithBalances);      setBalanceUpdateCounter(prev => prev + 1);      toast.success("Address balances updated");    } catch (err: any) {      console.error('Error querying addresses:', err);      toast.error("Failed to query addresses");    } finally {      setQueryingAddresses(false);    }  };  const handleShowTopUpInput = (address: string) => {    setShowTopUpInput(prev => ({      ...prev,      [address]: true    }));    setTopUpAmounts(prev => ({      ...prev,      [address]: prev[address] || "0.1"    }));  };  const handleTopUpAmountChange = (address: string, value: string) => {    if (/^(\d+)?(\.\d*)?$/.test(value) || value === '') {      setTopUpAmounts(prev => ({        ...prev,        [address]: value      }));    }  };  const handleTopUp = async (address: string) => {    if (!wallet || !connected || !publicKey || !sendTransaction) {      toast.error('Please connect your wallet');      return;    }    const amount = topUpAmounts[address];    if (!amount || parseFloat(amount) <= 0) {      toast.error('Please enter a valid amount');      return;    }    setToppingUp(true);    setTopUpAddress(address);    setError('');    setStatus('Initializing top-up...');    try {      const connection = await createRpc(process.env.NEXT_PUBLIC_RPC_URL || "https://api.mainnet-beta.solana.com");      const transferAmount = parseFloat(amount) * 1e9; // Convert SOL to lamports            setStatus('Checking private balance...');      const currentPrivateBalance = await checkPrivateBalance(publicKey.toString());      const currentPrivateLamports = (parseFloat(currentPrivateBalance || '0') * 1e9);            const FEE_BUFFER = 200000; // 0.0002 SOL in lamports      const neededAdditionalLamports = Math.max(0, transferAmount - currentPrivateLamports + FEE_BUFFER);      if (neededAdditionalLamports > 0) {        setStatus(`Shielding additional ${(neededAdditionalLamports / 1e9).toFixed(4)} SOL (includes fee buffer)...`);        const compressInstruction = await LightSystemProgram.compress({          payer: publicKey,          toAddress: publicKey,          lamports: neededAdditionalLamports,          outputStateTree: defaultTestStateTreeAccounts().merkleTree,        });        const compressInstructions = [          ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }),          compressInstruction,        ];        const { context: { slot: minContextSlot }, value: blockhashCtx } =          await connection.getLatestBlockhashAndContext();        const messageV0 = new TransactionMessage({          payerKey: publicKey,          recentBlockhash: blockhashCtx.blockhash,          instructions: compressInstructions,        }).compileToV0Message();        const transaction = new VersionedTransaction(messageV0);        setStatus('Sending shield transaction...');        const signature = await sendTransaction(transaction, connection, {          minContextSlot,        });        await connection.confirmTransaction({          signature,          ...blockhashCtx        });        await new Promise(resolve => setTimeout(resolve, 2000));                setStatus(`✅ Successfully shielded funds! Continuing with top-up...`);                await new Promise(resolve => setTimeout(resolve, 1000));      }      setStatus('Getting compressed accounts...');      const accounts = await connection.getCompressedAccountsByOwner(publicKey);            if (!accounts || !accounts.items || accounts.items.length === 0) {        throw new Error('No compressed accounts found. Please shield some SOL first.');      }      setStatus('Selecting accounts for transfer...');      const [selectedAccounts, remaining] = selectMinCompressedSolAccountsForTransfer(        accounts.items,        transferAmount      );            if (!selectedAccounts || selectedAccounts.length === 0) {        throw new Error('Could not select appropriate accounts for transfer. Please shield more SOL.');      }      setStatus('Getting validity proof...');      const hashes = selectedAccounts.map(account => {        if (!account.hash || account.hash.length === 0) {          throw new Error('Invalid account hash found');        }        const hashBuffer = Buffer.from(account.hash);        return BigInt('0x' + hashBuffer.toString('hex'));      });            if (hashes.length === 0) {        throw new Error('No account hashes available for proof generation');      }            const { compressedProof, rootIndices } = await connection.getValidityProof(hashes);      setStatus('Creating private transfer...');      const sendInstruction = await LightSystemProgram.transfer({        payer: publicKey,        toAddress: new PublicKey(address),        lamports: transferAmount,        inputCompressedAccounts: selectedAccounts,        outputStateTrees: [defaultTestStateTreeAccounts().merkleTree],        recentValidityProof: compressedProof,        recentInputStateRootIndices: rootIndices,      });      const sendInstructions = [        ComputeBudgetProgram.setComputeUnitLimit({ units: 1_000_000 }),        sendInstruction,      ];      const { context: { slot: minContextSlotSend }, value: blockhashSend } =        await connection.getLatestBlockhashAndContext();      setStatus('Preparing private transfer...');      const messageV0Send = new TransactionMessage({        payerKey: publicKey,        recentBlockhash: blockhashSend.blockhash,        instructions: sendInstructions,      }).compileToV0Message();      const transactionSend = new VersionedTransaction(messageV0Send);      setStatus('Sending private transfer...');            const signatureSend = await sendTransaction(transactionSend, connection, {        minContextSlot: minContextSlotSend,      });      await connection.confirmTransaction({
        signature: signatureSend,
        blockhash: blockhashSend.blockhash,
        lastValidBlockHeight: blockhashSend.lastValidBlockHeight,
      });      setStatus(`✅ Top-up Completed Successfully`);            setShowTopUpInput(prev => ({        ...prev,        [address]: false      }));            await queryTradingAddresses();      toast.success("Trading address topped up successfully");    } catch (err: any) {      console.error('Top-up error:', err);      setError(err.message || 'Failed to process top-up transaction');      toast.error("Failed to top up trading address");    } finally {      setToppingUp(false);      setTopUpAddress('');    }  };  const handleCopyAddress = (address: string) => {    navigator.clipboard.writeText(address);    toast.success('Address copied to clipboard');  };  useEffect(() => {    console.log("Current addressBalances state:", addressBalances);  }, [addressBalances]);  useEffect(() => {    if (publicKey && tradingAddresses.length > 0) {      queryTradingAddresses();    }  }, [publicKey, tradingAddresses]);  return (    <div className="space-y-4 text-center mx-auto">      <h2 className="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-purple-400 to-indigo-300">Trading Wallet Management</h2>      <p className="text-white/70">Generate and manage your private trading addresses.</p>            <Card className="bg-zinc-900/40 backdrop-blur-sm border border-zinc-800/50 mt-6">        <CardContent className="pt-6">          <div className="space-y-4">            <div className="flex justify-between items-center">              <h3 className="text-lg font-medium text-white">Your Trading Addresses</h3>              <Button size="sm" variant="outline" className="gap-1" onClick={displayTradingAddresses} disabled={generatingAddress || !publicKey}>                {generatingAddress ? (                  <Loader2 className="h-4 w-4 animate-spin" />                ) : (                  <Wallet className="h-4 w-4" />                )}                {generatingAddress ? "Generating..." : "View Addresses"}              </Button>            </div>                        {/* Status and Error Messages */}            {status && (              <div className="mb-4 p-3 bg-blue-900/20 border border-blue-800/30 rounded-lg text-sm text-blue-300">                {status}              </div>            )}                        {error && (              <div className="mb-4 p-3 bg-red-900/20 border border-red-800/30 rounded-lg text-sm text-red-300">                {error}              </div>            )}                        {/* Refresh Button */}            {tradingAddresses.length > 0 && (              <Button                 className="w-full mb-4 bg-zinc-800 hover:bg-zinc-700 text-white font-medium py-2 px-4 rounded-lg flex items-center justify-center transition-all duration-300"                onClick={queryTradingAddresses}                disabled={queryingAddresses || !publicKey}              >                {queryingAddresses ? (                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />                ) : (                  <RefreshCw className="mr-2 h-4 w-4" />                )}                {queryingAddresses ? "Updating Balances..." : "Refresh Balances"}              </Button>            )}                        {/* Trading Addresses List */}            {tradingAddresses.length === 0 ? (              <div className="p-4 bg-[#131320] rounded-lg border border-zinc-800/50 text-center text-white/70">                No trading addresses generated yet. Click "View Addresses" to create them.              </div>            ) : (              tradingAddresses.map((address, index) => {                console.log(`Rendering address ${address.address} with balance:`, addressBalances[address.address]);                                return (                  <div key={`${address.address}-${balanceUpdateCounter}`} className="bg-[#131320] rounded-lg border border-zinc-800/50 overflow-hidden">                    {/* Address Header - Always visible */}                    <button                       className="w-full p-4 flex items-center justify-between text-left hover:bg-[#1E1E2D]/30 transition-colors"                      onClick={() => setExpandedAddresses(prev => ({                        ...prev,                        [address.address]: !prev[address.address]                      }))}                    >                      <div className="flex items-center">                        <div className="flex-shrink-0 h-6 w-6 rounded-full bg-purple-900/40 flex items-center justify-center text-xs font-medium text-purple-300 mr-3">                          {index + 1}                        </div>                        <div>                          <div className="text-xs text-white/60 mb-1">Trading Address {index + 1}</div>                          <div className="font-mono text-sm text-white/90 truncate max-w-[180px] md:max-w-[250px]">                            {address.address.substring(0, 8)}...{address.address.substring(address.address.length - 8)}                          </div>                        </div>                      </div>                      <div className="flex items-center">                        {expandedAddresses[address.address] ? (                          <ChevronUp className="h-4 w-4 text-white/70" />                        ) : (                          <ChevronDown className="h-4 w-4 text-white/70" />                        )}                      </div>                    </button>                                        {/* Collapsible Content */}                    {expandedAddresses[address.address] && (                      <>                        {/* Full Address Display */}                        <div className="px-4 py-3 border-t border-zinc-800/30 flex items-center justify-between">                          <div className="font-mono text-xs text-white/80 break-all">{address.address}</div>                          <div className="flex space-x-2 ml-2 flex-shrink-0">                            <button                               onClick={() => handleCopyAddress(address.address)}                              className="text-white/70 hover:text-white"                            >                              <Copy className="h-4 w-4" />                            </button>                          </div>                        </div>                                                {/* Balance Display */}                        <div className="px-4 py-3 flex justify-between border-t border-zinc-800/30">                              <div>                            <div className="text-xs text-white/60">Public</div>                            <div className="text-sm font-medium text-white">                              {addressBalances[address.address]?.public || "0.0000"} SOL                            </div>                          </div>                          <div>                            <div className="text-xs text-white/60">Private</div>                            <div className="text-sm font-medium text-white">                              {addressBalances[address.address]?.private || "0.0000"} SOL                            </div>                          </div>                          <div className="text-right">                            <div className="text-xs text-white/60">Total</div>                            <div className="text-sm font-medium text-white">                              {addressBalances[address.address]?.total || "0.0000"} SOL                            </div>                          </div>                        </div>                                                {/* Top Up Input and Button */}                        {showTopUpInput[address.address] ? (                          <div className="px-4 py-3 border-t border-zinc-800/30">                            <div className="flex items-center space-x-2">                              <div className="relative flex-1">                                <input                                  type="text"                                  value={topUpAmounts[address.address] || ''}                                  onChange={(e) => handleTopUpAmountChange(address.address, e.target.value)}                                  className="w-full bg-zinc-800/50 border border-zinc-700/50 rounded-lg px-3 py-2 text-white placeholder-zinc-500 focus:outline-none focus:ring-2 focus:ring-purple-500/50"                                  placeholder="Amount in SOL"                                  disabled={toppingUp}                                />                                <div className="absolute right-3 top-1/2 transform -translate-y-1/2 text-zinc-500">                                  SOL                                </div>                              </div>                              <Button                                onClick={() => handleTopUp(address.address)}                                disabled={toppingUp || !topUpAmounts[address.address] || parseFloat(topUpAmounts[address.address] || '0') <= 0}                                className="bg-green-800/30 hover:bg-green-700/40 text-green-400 px-4 py-2 rounded-lg"                              >                                {toppingUp && topUpAddress === address.address ? (                                  <Loader2 className="h-4 w-4 animate-spin" />                                ) : (                                  "Confirm"                                )}                              </Button>                              <Button                                onClick={() => setShowTopUpInput(prev => ({                                  ...prev,                                  [address.address]: false                                }))}                                disabled={toppingUp && topUpAddress === address.address}                                className="bg-zinc-800/50 hover:bg-zinc-700/50 text-zinc-400 px-4 py-2 rounded-lg"                              >                                Cancel                              </Button>                            </div>                          </div>                        ) : (                          <button                             className="w-full bg-transparent hover:bg-green-900/20 text-green-400 border-t border-zinc-800/30 py-3 flex items-center justify-center transition-colors"                            onClick={() => handleShowTopUpInput(address.address)}                            disabled={toppingUp}                          >                            <Plus className="h-4 w-4 mr-2" />                            Top Up Trading Address                          </button>                        )}                      </>                    )}                  </div>                );              })            )}          </div>        </CardContent>      </Card>    </div>  );}
